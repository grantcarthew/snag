#!/usr/bin/env bash

# Copyright (c) 2025 Grant Carthew
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

# Interactive Testing Script for Snag
# Reads test-interactive.csv and executes tests with user verification

# Environment setup
# -----------------------------------------------------------------------------
set -o pipefail
[[ ${DEBUG-} ]] && set -o xtrace

SCRIPT_DIR="$(cd "${BASH_SOURCE[0]%/*}" || exit 1; pwd)"
CSV_FILE="${SCRIPT_DIR}/test-interactive.csv"

# ANSI color codes
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly BOLD='\033[1m'
readonly RESET='\033[0m'

# Embedded logging functions (standalone, no external dependencies)
# -----------------------------------------------------------------------------
function log_line() {
    local char="${1:-─}"
    local length="${2:-80}"
    printf "${char}%.0s" $(seq 1 "${length}") >&2
    echo >&2
}

function log_title() {
    echo >&2
    log_line "═" 80
    echo -e "${BOLD}${GREEN}${1}${RESET}" >&2
    log_line "═" 80
}

function log_heading() {
    echo >&2
    echo -e "${BOLD}${GREEN}${1}${RESET}" >&2
    log_line "─" "${#1}"
}

function log_message() {
    echo -e "${1}" >&2
}

function log_success() {
    echo -e "${GREEN}✔${RESET} ${1}" >&2
}

function log_failure() {
    echo -e "${RED}✖${RESET} ${1}" >&2
}

function log_error() {
    echo -e "${RED}${1}${RESET}" >&2
}

function log_warning() {
    echo -e "${YELLOW}${1}${RESET}" >&2
}

function log_info() {
    echo -e "${BLUE}${1}${RESET}" >&2
}

function log_pressanykey() {
    echo -e "${YELLOW}Press any key to continue...${RESET}" >&2
    read -n 1 -s -r || true  # Don't exit on EOF or error
    echo >&2
}

function ctrlc_trap() {
    echo >&2
    log_warning "Testing interrupted. Exiting."
    exit 130
}
trap ctrlc_trap SIGINT

# Browser state detection functions
# -----------------------------------------------------------------------------
function browser_is_running() {
    # Returns 0 if browser is running and accessible, 1 otherwise
    "${SNAG_BIN:-./snag}" --list-tabs >/dev/null 2>&1
    return $?
}

function count_browser_tabs() {
    # Returns the number of open browser tabs (0 if browser not running)
    local count=0
    if browser_is_running; then
        # Count lines from --list-tabs, subtract header lines
        count=$("${SNAG_BIN:-./snag}" --list-tabs 2>/dev/null | grep -c '^\s*\[')
    fi
    echo "${count}"
}

function setup_browser_tabs() {
    # Load test URLs into browser tabs
    local url_file="${1:-${SCRIPT_DIR}/testdata/test-urls-5.txt}"

    log_message "Loading test URLs into browser tabs..."

    if [[ ! -f "${url_file}" ]]; then
        log_error "URL file not found: ${url_file}"
        return 1
    fi

    # Read URLs and open them in browser
    while IFS= read -r url; do
        # Skip comments and empty lines
        [[ "${url}" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${url// }" ]] && continue

        log_message "  Loading: ${url}"
        "${SNAG_BIN:-./snag}" --open-browser "${url}" >/dev/null 2>&1
        sleep 0.5  # Brief pause between tabs
    done < "${url_file}"

    log_success "Test URLs loaded successfully"
}

function quit_browser() {
    # Force kill all Chromium-based browser processes
    local quit_count=0

    if [[ "$(uname)" == "Darwin" ]]; then
        # macOS - force kill all browser processes
        local processes=("Google Chrome" "Chromium" "Brave Browser" "Microsoft Edge")
        for process in "${processes[@]}"; do
            if pkill -9 -f "${process}" 2>/dev/null; then
                ((quit_count++))
            fi
        done
    else
        # Linux - force kill browser processes
        local processes=("chrome" "chromium" "chromium-browser" "brave" "microsoft-edge")
        for process in "${processes[@]}"; do
            if pkill -9 -f "${process}" 2>/dev/null; then
                ((quit_count++))
            fi
        done
    fi

    if [[ ${quit_count} -gt 0 ]]; then
        sleep 1  # Give processes time to terminate
        log_success "Killed ${quit_count} browser process(es)"
    else
        log_message "No browser processes to kill"
    fi
}

# Dependency checks
# -----------------------------------------------------------------------------
dependencies=(go fzf)
for cmd in "${dependencies[@]}"; do
    if ! command -v "${cmd}" >/dev/null; then
        log_error "ERROR: Missing dependency - '${cmd}'"
        exit 1
    fi
done

# Main script
# -----------------------------------------------------------------------------
log_title "Snag Interactive Testing Suite"

# Build snag
log_heading "Building Snag"
if ! go build -o snag; then
    log_failure "Failed to build snag"
    exit 1
fi
log_success "Built snag binary successfully"

# Verify CSV file exists
if [[ ! -f "${CSV_FILE}" ]]; then
    log_error "ERROR: CSV file not found: ${CSV_FILE}"
    exit 1
fi

# Create temp directory
log_heading "Test Environment Setup"
TEST_DIR=$(mktemp -d -t snag-test-XXXXXX)
log_message "Created temporary test directory: ${TEST_DIR}"
SNAG_BIN="${SCRIPT_DIR}/snag"

# Copy snag binary to temp dir for easier commands
cp "${SNAG_BIN}" "${TEST_DIR}/snag"

# Copy testdata directory to temp dir (for --url-file tests)
if [[ -d "${SCRIPT_DIR}/testdata" ]]; then
    cp -r "${SCRIPT_DIR}/testdata" "${TEST_DIR}/"
    log_message "Copied testdata directory to test environment"
fi

cd "${TEST_DIR}" || exit 1
log_success "Working directory: ${TEST_DIR}"

# Parse CSV and extract sections
log_heading "Loading Test Definitions"
mapfile -t csv_lines < <(tail -n +2 "${CSV_FILE}")  # Skip header
log_success "Loaded ${#csv_lines[@]} tests from CSV"

# Extract unique sections for fzf selection
declare -a sections=()
while IFS=, read -r section _; do
    if [[ ! " ${sections[*]} " =~ " ${section} " ]]; then
        sections+=("${section}")
    fi
done < <(tail -n +2 "${CSV_FILE}")

# Add "All" option
sections=("All" "${sections[@]}")

# Use fzf for section selection
log_heading "Section Selection"
log_message "Select test section(s) to run (use Tab for multi-select, Enter to confirm):"
selected_sections=$(printf '%s\n' "${sections[@]}" | fzf --multi --height=40% --border --prompt="Select sections: " --header="Tab=multi-select, Enter=confirm" --bind='tab:toggle+down')

if [[ -z "${selected_sections}" ]]; then
    log_warning "No sections selected. Exiting."
    exit 0
fi

# Convert selected sections to array
mapfile -t selected_array <<< "${selected_sections}"

# Determine which tests to run
declare -a tests_to_run=()
if [[ " ${selected_array[*]} " =~ " All " ]]; then
    # If "All" is selected, run all tests
    tests_to_run=("${csv_lines[@]}")
    log_message "Running ALL tests"
else
    # Otherwise, filter by selected sections
    for line in "${csv_lines[@]}"; do
        IFS=, read -r section description verify requires command <<< "${line}"

        # Check if this test's section is in selected sections
        if [[ " ${selected_array[*]} " =~ " ${section} " ]]; then
            tests_to_run+=("${line}")
        fi
    done
fi

log_success "Will run ${#tests_to_run[@]} tests"
echo >&2

# Debug: Show first few tests to verify
if [[ ${DEBUG-} ]]; then
    log_message "First 3 tests:"
    for i in 0 1 2; do
        [[ $i -lt ${#tests_to_run[@]} ]] && log_message "  [$i] ${tests_to_run[$i]}"
    done
    echo >&2
fi

# Pre-test setup: Determine requirements and setup browser if needed
# -----------------------------------------------------------------------------
log_heading "Browser Setup"

# Determine highest requirement from tests
highest_requirement="none"
for test_line in "${tests_to_run[@]}"; do
    IFS=, read -r section description verify requires command <<< "${test_line}"

    if [[ "${requires}" == "tabs" ]]; then
        highest_requirement="tabs"
        break  # tabs is highest, no need to continue
    elif [[ "${requires}" == "browser" && "${highest_requirement}" == "none" ]]; then
        highest_requirement="browser"
    fi
done

# Detect current browser state
browser_running=false
tab_count=0
if browser_is_running; then
    browser_running=true
    tab_count=$(count_browser_tabs)
fi

# Display browser status
log_message "Current State:"
log_message "  Browser running: $(${browser_running} && echo "Yes" || echo "No")"
log_message "  Tab count: ${tab_count}"
log_message "  Requirement: ${highest_requirement}"
echo >&2

# Execute setup based on requirements
MIN_TABS=3  # Minimum tabs required for tab operations

if [[ "${highest_requirement}" == "tabs" ]]; then
    if ! ${browser_running} || [[ ${tab_count} -lt ${MIN_TABS} ]]; then
        log_message "Action: Loading test URLs (browser needs tabs)..."
        setup_browser_tabs "${SCRIPT_DIR}/testdata/test-urls-5.txt"

        # Re-count tabs after setup
        tab_count=$(count_browser_tabs)
        log_success "Browser ready with ${tab_count} tabs"
    else
        log_success "Action: Ready (requirements met - ${tab_count} tabs available)"
    fi
elif [[ "${highest_requirement}" == "browser" ]]; then
    if ! ${browser_running}; then
        log_message "Action: Opening browser..."
        "${SNAG_BIN}" --open-browser >/dev/null 2>&1
        log_success "Browser opened"
    else
        log_success "Action: Ready (browser already running)"
    fi
else
    log_success "Action: No browser setup required"
fi

echo >&2

# Run tests
test_count=0
passed_count=0
failed_count=0

log_heading "Starting Test Execution"
log_message "Total tests to run: ${#tests_to_run[@]}"
echo >&2

for test_line in "${tests_to_run[@]}"; do
    # Parse CSV line - be careful with IFS
    IFS=, read -r section description verify requires command <<< "${test_line}"
    ((test_count++))

    # Auto-cleanup if more than 20 files in test directory
    file_count=$(find . -maxdepth 1 -type f ! -name "snag" | wc -l)
    if [[ ${file_count} -gt 20 ]]; then
        log_message "Cleaning up ${file_count} files from previous tests..."
        find . -maxdepth 1 -type f ! -name "snag" -delete
        log_success "Test directory cleaned"
        echo >&2
    fi

    # Quit browser if this test requires it
    if [[ "${description}" == "Open browser only (no URL)" || \
          "${description}" == "Error on non-existent profile dir" || \
          "${description}" == "Custom User Agent" || \
          "${description}" == "Force headless browser" || \
          "${description}" == "Custom port" || \
          "${description}" == "Open browser with custom profile" ]]; then
        log_message "Quitting browser for fresh test: ${description}..."
        quit_browser
        echo >&2
    fi

    log_heading "Test ${test_count}/${#tests_to_run[@]}: ${description}"
    log_message "Section: ${section}"
    log_message "Working directory: $(pwd)"
    log_line "─" 40
    echo >&2
    log_message "${BLUE}${command}${RESET}"

    # Capture existing files before running command (for tracking new files)
    declare -a files_before=()
    while IFS= read -r -d '' file; do
        files_before+=("${file}")
    done < <(find . -maxdepth 1 -type f ! -name "snag" -print0 2>/dev/null)

    # Run the command, capture stderr to extract filename later
    set +e  # Don't exit on error
    eval "${command}" 2> >(tee /tmp/snag-test-stderr.txt >&2)
    exit_code=$?
    set +e  # Keep it off! Don't use set -e
    sleep 0.1  # Brief pause to ensure stderr is fully captured

    echo >&2
    echo >&2
    log_line "─" 40

    # Handle verification based on verify column
    case "${verify}" in
        "error")
            if [[ ${exit_code} -ne 0 ]]; then
                log_success "Expected error occurred (exit code: ${exit_code})"
                ((passed_count++))
            else
                log_failure "Expected error but command succeeded"
                ((failed_count++))
            fi
            ;;

        "stdout")
            if [[ ${exit_code} -eq 0 ]]; then
                log_success "Command succeeded (output shown above)"
                ((passed_count++))
            else
                log_failure "Command failed (exit code: ${exit_code})"
                ((failed_count++))
            fi
            ;;

        file:*)
            filepath="${verify#file:}"
            if [[ ${exit_code} -eq 0 && -f "${filepath}" ]]; then
                log_success "Command succeeded, file created: ${filepath}"
                log_message "${BOLD}File contents:${RESET}"
                cat "${filepath}" || log_warning "Could not read file"
                ((passed_count++))
            else
                log_failure "Command failed or file not created (exit code: ${exit_code})"
                ((failed_count++))
            fi
            ;;

        open:*)
            filepath="${verify#open:}"
            if [[ ${exit_code} -eq 0 && -f "${filepath}" ]]; then
                log_success "Command succeeded, file created: ${filepath}"
                log_message "Opening file: ${filepath}"
                if command -v open >/dev/null 2>&1; then
                    open "${filepath}" 2>/dev/null || log_warning "Could not open file"
                elif command -v xdg-open >/dev/null 2>&1; then
                    xdg-open "${filepath}" 2>/dev/null || log_warning "Could not open file"
                else
                    log_warning "No opener found (tried 'open' and 'xdg-open')"
                fi
                ((passed_count++))
            else
                log_failure "Command failed or file not created (exit code: ${exit_code})"
                ((failed_count++))
            fi
            ;;

        "ls")
            if [[ ${exit_code} -eq 0 ]]; then
                log_success "Command succeeded"

                # Find all NEW files created by this test
                declare -a files_after=()
                while IFS= read -r -d '' file; do
                    files_after+=("${file}")
                done < <(find . -maxdepth 1 -type f ! -name "snag" -print0 2>/dev/null)

                declare -a new_files=()
                for file in "${files_after[@]}"; do
                    # Check if this file is new (not in files_before)
                    is_new=true
                    for old_file in "${files_before[@]}"; do
                        if [[ "${file}" == "${old_file}" ]]; then
                            is_new=false
                            break
                        fi
                    done
                    if [[ "${is_new}" == "true" ]]; then
                        new_files+=("${file}")
                    fi
                done

                # Display new files created
                if [[ ${#new_files[@]} -gt 0 ]]; then
                    log_message "${BOLD}Files created (${#new_files[@]}):${RESET}"
                    for file in "${new_files[@]}"; do
                        log_message "  - ${file}"
                    done
                    echo >&2

                    # For single file: show content or open
                    if [[ ${#new_files[@]} -eq 1 ]]; then
                        file="${new_files[0]}"
                        case "${file}" in
                            *.md|*.html|*.txt)
                                log_message "${BOLD}File contents:${RESET}"
                                cat "${file}" || log_warning "Could not read ${file}"
                                ;;
                            *.pdf|*.png)
                                log_message "Opening: ${file}"
                                if command -v open >/dev/null 2>&1; then
                                    open "${file}" 2>/dev/null || log_warning "Could not open ${file}"
                                elif command -v xdg-open >/dev/null 2>&1; then
                                    xdg-open "${file}" 2>/dev/null || log_warning "Could not open ${file}"
                                else
                                    log_warning "No opener found"
                                fi
                                ;;
                        esac
                    # For multiple files: open binary files only
                    elif [[ ${#new_files[@]} -gt 1 ]]; then
                        for file in "${new_files[@]}"; do
                            case "${file}" in
                                *.pdf|*.png)
                                    log_message "Opening: ${file}"
                                    if command -v open >/dev/null 2>&1; then
                                        open "${file}" 2>/dev/null
                                    elif command -v xdg-open >/dev/null 2>&1; then
                                        xdg-open "${file}" 2>/dev/null
                                    fi
                                    ;;
                            esac
                        done
                    fi
                else
                    log_warning "No new files created"
                fi

                ((passed_count++))
            else
                log_failure "Command failed (exit code: ${exit_code})"
                ((failed_count++))
            fi
            ;;

        *)
            log_warning "Unknown verify action: ${verify}"
            log_message "Command exit code: ${exit_code}"
            ;;
    esac

    echo >&2
    log_pressanykey
done

# Summary
log_title "Test Summary"
log_message "Total tests: ${test_count}"
log_success "Passed: ${passed_count}"
if [[ ${failed_count} -gt 0 ]]; then
    log_failure "Failed: ${failed_count}"
fi

# Cleanup prompt
echo >&2
log_heading "Cleanup"
log_message "Test directory: ${TEST_DIR}"
read -p "Keep test directory? [Y/n]: " -n 1 -r
echo >&2
if [[ ! $REPLY =~ ^[Yy]$ ]] && [[ ! -z $REPLY ]]; then
    log_message "Removing test directory..."
    rm -rf "${TEST_DIR}"
    log_success "Cleaned up test directory"
else
    log_success "Test directory preserved: ${TEST_DIR}"
fi

log_success "Testing complete!"
